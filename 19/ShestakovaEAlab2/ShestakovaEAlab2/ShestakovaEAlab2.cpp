// ShestakovaEAlab2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include "ShestakovaEA.h"

using namespace std;

using Program::ShestakovaEA;
using Program::ProizShestakovaEA;

int _tmain(int argc, _TCHAR* argv[])
{
	//Полиморфизмом в программировании называется переопределение наследником функций-членов базового класса
	
	setlocale(LC_ALL, "rus");
	ShestakovaEA s; //объект s базового класса
	ShestakovaEA *b1; // указатель на базовый класс
	b1 = &s;// этому указателю присвоен адрес объекта базового класса s
	cout << " указатель на базовый класс, которому присвоен объект базового класса:" << endl;
	b1->simplefunc();// вызов функций: исполнение простой функции, принадл базовому классу
	b1->virtfunc();//т к виртуальная функция , то программа определяет на этапе исполнения
	// какую функцию употребить. тк объект типа базового класса то исполняется версия вирт функции базового класса
	
	/*функция virtfunc объявлена как виртуальная.Это означает, 
		что эта функция может быть переопределена в производных классах.
		В производном классе функция virtfunc переопределена.*/

	cout << "________" << endl;

	
	ProizShestakovaEA p;
	ProizShestakovaEA *b2;
	b2 = &p;//указателю производного класса присвоен адрес объекта производного класса, 
	//те исполняется версия прост/вирт функций, объявленных в производном классе
	cout << "указатель на производный класс, которому присвоен объект производного класса:" << endl;
	b2->simplefunc();
	b2->virtfunc();

	cout << "________" << endl;
	ShestakovaEA *b3;
	int k;
	cin >> k;
	if (k==0) 
	b3 = b2;
	else b3 = b1;
	//указателю базового класса присвоен адрес объекта производного класса, что говорит о полиморфизме времени исполнения
	//Полиморфизм времени исполнения достигается только 
	//при вызове виртуальной функции с использованием указателя или ссылки на базовый класс.
	//При вызове простой функции полиморфизм времени исполнения не достигается,происходит 
	cout << "указатель на базовый класс, которому присвоен объект из второго указателя:" << endl;
	b3->simplefunc();//-перекрытие методов-вне зависимости от того, указатель базвого класса ссылается на адрес объекта производного или базового класса
	//простая функция вызовется из базавого класса
	//Возможность вызова методов производного класса через ссылку или указатель на базовый класс 
	//осуществляется с помощью механизма виртуальных функций.
	b3->virtfunc();

	//Если функция была объявлена как виртуальная, то она и остается 
	//таковой вне зависимости от количества уровней в иерархии классов, через которые она прошла. 
	cout << "________" << endl;
	cout << " указатель на производный класс, которому с использованием статической операции приведения типа присвоен объект из третьего указателя:" << endl;
	ProizShestakovaEA *b4;
	b4 = dynamic_cast<ProizShestakovaEA*>(b3);
	if (b4 != 0)
	{
		b4->simplefunc();
		b4->virtfunc();
	}
	//static_cast преобразует выражения одного статического типа-b3- в объекты и значения другого статического типа-b4-. 
	//Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз(!). 
	

	system("pause");
}

